/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPEEDYCRM EMAIL FUNCTIONS - MEGA ENTERPRISE EDITION
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Comprehensive Firebase Cloud Functions for email automation with enterprise-grade
 * reliability, monitoring, error recovery, and admin controls.
 * 
 * @version 2.0.0 - MEGA ENTERPRISE
 * @author SpeedyCRM Engineering Team
 * @date 2025-10-30
 * 
 * FEATURES:
 * ✅ Automatic workflow triggers on contact creation
 * ✅ Scheduled workflow processing with cron jobs
 * ✅ SendGrid webhook integration for email tracking
 * ✅ Manual workflow controls (start, pause, resume, stop)
 * ✅ Health monitoring and diagnostics
 * ✅ Rate limiting and abuse prevention
 * ✅ Comprehensive error handling and recovery
 * ✅ Admin controls and emergency stops
 * ✅ Detailed logging and analytics
 * ✅ Audit trail for compliance
 * ✅ Retry logic with exponential backoff
 * ✅ Dead letter queue for failed operations
 * ✅ Real-time monitoring endpoints
 * ✅ Performance metrics and alerts
 * ✅ Email deliverability tracking
 * ✅ Unsubscribe management
 * ✅ Template management and versioning
 * ✅ A/B testing support
 * ✅ Timezone-aware scheduling
 * ✅ Bulk operations with throttling
 * ✅ Contact engagement scoring
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 */

// ═══════════════════════════════════════════════════════════════════════════
// IMPORTS AND DEPENDENCIES
// ═══════════════════════════════════════════════════════════════════════════

const functions = require('firebase-functions');
const { sendEmail, verifyWebhookSignature } = require('./sendGridService');
const { processWorkflowStage, getWorkflowDefinition } = require('./emailWorkflowEngine');

// ═══════════════════════════════════════════════════════════════════════════
// FIRESTORE REFERENCES
// ═══════════════════════════════════════════════════════════════════════════

const { db, admin } = require('./firebaseAdmin');
const contactsRef = db.collection('contacts');
const emailLogsRef = db.collection('emailLogs');
const workflowStateRef = db.collection('workflowState');
const scheduledStagesRef = db.collection('scheduledStages');
const unsubscribedRef = db.collection('unsubscribed');
const deadLetterQueueRef = db.collection('deadLetterQueue');
const systemMetricsRef = db.collection('systemMetrics');
const auditLogsRef = db.collection('auditLogs');
const configRef = db.collection('systemConfig');

// ═══════════════════════════════════════════════════════════════════════════
// CONFIGURATION AND CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════

// Secret declarations for SendGrid configuration
const SENDGRID_API_KEY = functions.config().sendgrid?.key || process.env.SENDGRID_API_KEY;
const FROM_EMAIL = functions.config().sendgrid?.from_email || process.env.FROM_EMAIL;
const REPLY_TO_EMAIL = functions.config().sendgrid?.reply_to_email || process.env.REPLY_TO_EMAIL;

// System limits and thresholds
const CONFIG = {
  MAX_RETRIES: 3,
  RETRY_DELAY_MS: 1000,
  RETRY_MULTIPLIER: 2,
  MAX_RETRY_DELAY_MS: 30000,
  
  RATE_LIMITS: {
    EMAILS_PER_MINUTE: 60,
    EMAILS_PER_HOUR: 1000,
    EMAILS_PER_DAY: 10000,
    WORKFLOWS_PER_MINUTE: 100,
    WEBHOOKS_PER_MINUTE: 500
  },
  
  MONITORING: {
    HEALTH_CHECK_INTERVAL_MS: 300000, // 5 minutes
    METRICS_RETENTION_DAYS: 90,
    LOG_RETENTION_DAYS: 30,
    ALERT_THRESHOLD_ERROR_RATE: 0.05, // 5% error rate
    ALERT_THRESHOLD_RESPONSE_TIME_MS: 5000
  },
  
  WORKFLOW: {
    MAX_ACTIVE_WORKFLOWS: 50000,
    BATCH_SIZE: 100,
    PROCESSING_TIMEOUT_MS: 540000, // 9 minutes (Cloud Function limit)
    STAGE_TIMEOUT_MS: 30000,
    MAX_STAGES_PER_WORKFLOW: 50
  },
  
  EMAIL: {
    DEFAULT_TIMEOUT_MS: 10000,
    MAX_RECIPIENTS_PER_EMAIL: 1,
    MAX_SUBJECT_LENGTH: 200,
    MAX_BODY_LENGTH: 100000
  }
};

// ═══════════════════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Sleep function for delays with exponential backoff
 */
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Calculate exponential backoff delay
 */
const calculateBackoffDelay = (retryCount, baseDelay = CONFIG.RETRY_DELAY_MS) => {
  const delay = baseDelay * Math.pow(CONFIG.RETRY_MULTIPLIER, retryCount);
  return Math.min(delay, CONFIG.MAX_RETRY_DELAY_MS);
};

/**
 * Log to audit trail with metadata
 */
const logAudit = async (action, userId, metadata = {}) => {
  try {
    await auditLogsRef.add({
      action,
      userId,
      metadata,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      environment: process.env.NODE_ENV || 'production'
    });
  } catch (error) {
    console.error('Failed to write audit log:', error);
  }
};

/**
 * Record system metrics
 */
const recordMetric = async (metricName, value, tags = {}) => {
  try {
    const metricId = `${metricName}_${Date.now()}`;
    await systemMetricsRef.doc(metricId).set({
      name: metricName,
      value,
      tags,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
  } catch (error) {
    console.error('Failed to record metric:', error);
  }
};

/**
 * Check rate limits
 */
const checkRateLimit = async (limitType, identifier) => {
  const now = Date.now();
  const limitConfig = CONFIG.RATE_LIMITS[limitType];
  
  if (!limitConfig) {
    return { allowed: true, remaining: 999999 };
  }
  
  try {
    const rateLimitDoc = await db.collection('rateLimits')
      .doc(`${limitType}_${identifier}`)
      .get();
    
    if (!rateLimitDoc.exists) {
      await db.collection('rateLimits').doc(`${limitType}_${identifier}`).set({
        count: 1,
        resetAt: now + 60000,
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });
      return { allowed: true, remaining: limitConfig - 1 };
    }
    
    const data = rateLimitDoc.data();
    
    if (now > data.resetAt) {
      await rateLimitDoc.ref.update({
        count: 1,
        resetAt: now + 60000
      });
      return { allowed: true, remaining: limitConfig - 1 };
    }
    
    if (data.count >= limitConfig) {
      return { allowed: false, remaining: 0, resetAt: data.resetAt };
    }
    
    await rateLimitDoc.ref.update({
      count: admin.firestore.FieldValue.increment(1)
    });
    
    return { allowed: true, remaining: limitConfig - data.count - 1 };
  } catch (error) {
    console.error('Rate limit check failed:', error);
    return { allowed: true, remaining: 999999 }; // Fail open
  }
};

/**
 * Add item to dead letter queue
 */
const addToDeadLetterQueue = async (type, data, error, originalFunction) => {
  try {
    await deadLetterQueueRef.add({
      type,
      data,
      error: {
        message: error.message,
        stack: error.stack,
        code: error.code
      },
      originalFunction,
      attempts: data.retryCount || 0,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      status: 'failed'
    });
    
    await recordMetric('dead_letter_queue_items', 1, { type, function: originalFunction });
  } catch (dlqError) {
    console.error('Failed to add to dead letter queue:', dlqError);
  }
};

/**
 * Get system configuration with caching
 */
let configCache = null;
let configCacheTime = 0;
const CONFIG_CACHE_TTL = 300000; // 5 minutes

const getSystemConfig = async () => {
  const now = Date.now();
  
  if (configCache && (now - configCacheTime) < CONFIG_CACHE_TTL) {
    return configCache;
  }
  
  try {
    const configDoc = await configRef.doc('email_automation').get();
    
    if (configDoc.exists) {
      configCache = configDoc.data();
      configCacheTime = now;
      return configCache;
    }
    
    // Default configuration
    const defaultConfig = {
      enabled: true,
      maintenanceMode: false,
      maxConcurrentWorkflows: 100,
      emailsEnabled: true,
      webhooksEnabled: true,
      rateLimitingEnabled: true,
      lastUpdated: admin.firestore.FieldValue.serverTimestamp()
    };
    
    await configRef.doc('email_automation').set(defaultConfig);
    configCache = defaultConfig;
    configCacheTime = now;
    
    return defaultConfig;
  } catch (error) {
    console.error('Failed to get system config:', error);
    return { enabled: true, maintenanceMode: false }; // Fail safe
  }
};

/**
 * Validate email address format
 */
const isValidEmail = (email) => {
  if (!email || typeof email !== 'string') return false;
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email.trim().toLowerCase());
};

/**
 * Validate contact has required data for email
 */
const validateContactForEmail = (contact) => {
  const errors = [];
  
  if (!contact.id) {
    errors.push('Contact ID is required');
  }
  
  if (!contact.emails || !Array.isArray(contact.emails) || contact.emails.length === 0) {
    errors.push('Contact must have at least one email address');
  } else {
    const validEmails = contact.emails.filter(e => isValidEmail(e.address));
    if (validEmails.length === 0) {
      errors.push('Contact must have at least one valid email address');
    }
  }
  
  if (!contact.firstName && !contact.lastName && !contact.companyName) {
    errors.push('Contact must have a name or company name');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

/**
 * Enhanced retry logic with exponential backoff and circuit breaker
 */
const retryWithBackoff = async (operation, context, maxRetries = CONFIG.MAX_RETRIES) => {
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const result = await operation();
      
      if (attempt > 0) {
        console.log(`✅ Operation succeeded after ${attempt} retries:`, context);
        await recordMetric('retry_success', 1, { context, attempts: attempt });
      }
      
      return { success: true, result, attempts: attempt };
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries) {
        const delay = calculateBackoffDelay(attempt);
        console.log(`⚠️ Retry ${attempt + 1}/${maxRetries} for ${context} after ${delay}ms:`, error.message);
        await sleep(delay);
      }
    }
  }
  
  console.error(`❌ All ${maxRetries} retries failed for ${context}:`, lastError);
  await recordMetric('retry_exhausted', 1, { context, error: lastError.message });
  
  return { success: false, error: lastError, attempts: maxRetries };
};

// ═══════════════════════════════════════════════════════════════════════════
// MAIN CLOUD FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: onContactCreated                                            ║
 * ║ TRIGGER: Firestore onCreate - /contacts/{contactId}                  ║
 * ║ PURPOSE: Automatically start email workflow when contact is created  ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.onContactCreated = functions
  .runWith({
    timeoutSeconds: 540,
    memory: '2GB',
    secrets: ['SENDGRID_API_KEY', 'FROM_EMAIL', 'REPLY_TO_EMAIL']
  })
  .firestore
  .document('contacts/{contactId}')
  .onCreate(async (snap, context) => {
    const startTime = Date.now();
    const contactId = context.params.contactId;
    const contact = { id: contactId, ...snap.data() };
    
    console.log('═══════════════════════════════════════════════════════════');
    console.log('📧 NEW CONTACT CREATED - WORKFLOW TRIGGER');
    console.log('═══════════════════════════════════════════════════════════');
    console.log('Contact ID:', contactId);
    console.log('Lead Source:', contact.leadSource);
    console.log('Contact Type:', contact.contactType);
    console.log('Has Email:', contact.emails && contact.emails.length > 0);
    console.log('Has Phone:', contact.phones && contact.phones.length > 0);
    
    try {
      // Check system configuration
      const sysConfig = await getSystemConfig();
      
      if (!sysConfig.enabled || sysConfig.maintenanceMode) {
        console.log('⚠️ Email automation disabled or in maintenance mode');
        await recordMetric('workflow_skipped_maintenance', 1);
        return null;
      }
      
      // Check rate limits
      const rateLimit = await checkRateLimit('WORKFLOWS_PER_MINUTE', 'global');
      if (!rateLimit.allowed) {
        console.log('⚠️ Rate limit exceeded for workflow creation');
        await recordMetric('workflow_rate_limited', 1);
        
        // Queue for later processing
        await scheduledStagesRef.add({
          contactId,
          workflowId: null,
          stageIndex: 0,
          scheduledFor: admin.firestore.Timestamp.fromDate(new Date(rateLimit.resetAt)),
          status: 'pending',
          reason: 'rate_limited',
          createdAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        return null;
      }
      
      // Validate contact has email
      const validation = validateContactForEmail(contact);
      if (!validation.isValid) {
        console.log('⚠️ Contact validation failed:', validation.errors);
        console.log('   Skipping email workflow (no email address)');
        
        await contactsRef.doc(contactId).update({
          workflowStatus: 'not_eligible',
          workflowStatusReason: validation.errors.join('; '),
          workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        await recordMetric('workflow_skipped_no_email', 1);
        return null;
      }
      
      // Check if contact is unsubscribed
      const primaryEmail = contact.emails[0].address.toLowerCase();
      const unsubDoc = await unsubscribedRef.doc(primaryEmail).get();
      
      if (unsubDoc.exists) {
        console.log('⚠️ Contact is unsubscribed:', primaryEmail);
        
        await contactsRef.doc(contactId).update({
          workflowStatus: 'unsubscribed',
          workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        await recordMetric('workflow_skipped_unsubscribed', 1);
        return null;
      }
      
      // Determine workflow based on lead source
      let workflowId = 'manual'; // default
      
      if (contact.leadSource === 'ai_receptionist' || contact.leadSource === 'phone') {
        workflowId = 'ai-receptionist';
      } else if (contact.leadSource === 'website_form' || contact.leadSource === 'web') {
        workflowId = 'website-form';
      } else if (contact.leadSource === 'referral') {
        workflowId = 'referral';
      } else if (contact.leadSource === 'social_media') {
        workflowId = 'social-media';
      }
      
      console.log('📋 Selected workflow:', workflowId);
      
      // Get workflow definition
      const workflow = getWorkflowDefinition(workflowId);
      
      if (!workflow) {
        console.error('❌ Workflow definition not found:', workflowId);
        await recordMetric('workflow_definition_not_found', 1, { workflowId });
        
        await addToDeadLetterQueue(
          'workflow_start',
          { contactId, workflowId },
          new Error(`Workflow definition not found: ${workflowId}`),
          'onContactCreated'
        );
        
        return null;
      }
      
      // Check workflow entry conditions
      const meetsConditions = checkWorkflowEntryConditions(contact, workflow);
      
      if (!meetsConditions.eligible) {
        console.log('⚠️ Contact does not meet workflow entry conditions:', meetsConditions.reasons);
        
        await contactsRef.doc(contactId).update({
          workflowStatus: 'not_eligible',
          workflowStatusReason: meetsConditions.reasons.join('; '),
          workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        await recordMetric('workflow_conditions_not_met', 1, { workflowId });
        return null;
      }
      
      console.log('✅ Contact meets all entry conditions');
      
      // Initialize workflow state
      const workflowState = {
        contactId,
        workflowId,
        currentStage: 0,
        status: 'active',
        startedAt: admin.firestore.FieldValue.serverTimestamp(),
        lastProcessedAt: null,
        completedAt: null,
        pausedAt: null,
        errorCount: 0,
        stageHistory: [], // Array of stage completions (no serverTimestamp in arrays)
        metadata: {
          leadSource: contact.leadSource,
          contactType: contact.contactType,
          initialLeadScore: contact.leadScore || 0,
          workflowVersion: workflow.version || '1.0'
        }
      };
      
      // Create workflow state document
      const workflowStateDoc = await workflowStateRef.add(workflowState);
      
      console.log('✅ Workflow state created:', workflowStateDoc.id);
      
      // Update contact with workflow info
      await contactsRef.doc(contactId).update({
        workflowId,
        workflowStatus: 'active',
        workflowStateId: workflowStateDoc.id,
        workflowStartedAt: admin.firestore.FieldValue.serverTimestamp(),
        workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // Process the first stage with retry logic
      console.log('🚀 Processing first workflow stage...');
      
      const processResult = await retryWithBackoff(
        async () => {
          return await processWorkflowStage(contactId, workflowStateDoc.id);
        },
        `First stage for contact ${contactId}`
      );
      
      if (!processResult.success) {
        console.error('❌ Failed to process first workflow stage:', processResult.error);
        
        await workflowStateRef.doc(workflowStateDoc.id).update({
          status: 'error',
          errorCount: admin.firestore.FieldValue.increment(1),
          lastError: {
            message: processResult.error.message,
            timestamp: new Date().toISOString(),
            stage: 0
          }
        });
        
        await addToDeadLetterQueue(
          'workflow_stage',
          { contactId, workflowStateId: workflowStateDoc.id, stage: 0 },
          processResult.error,
          'onContactCreated'
        );
        
        await recordMetric('workflow_stage_failed', 1, { workflowId, stage: 0 });
      } else {
        console.log('✅ First workflow stage completed successfully');
        await recordMetric('workflow_started', 1, { workflowId });
      }
      
      // Log audit trail
      await logAudit('workflow_started', contactId, {
        workflowId,
        workflowStateId: workflowStateDoc.id,
        leadSource: contact.leadSource
      });
      
      // Record performance metrics
      const executionTime = Date.now() - startTime;
      await recordMetric('function_execution_time', executionTime, {
        function: 'onContactCreated',
        workflowId
      });
      
      console.log('═══════════════════════════════════════════════════════════');
      console.log('✅ CONTACT WORKFLOW INITIALIZATION COMPLETE');
      console.log(`⏱️  Execution time: ${executionTime}ms`);
      console.log('═══════════════════════════════════════════════════════════');
      
      return { success: true, workflowStateId: workflowStateDoc.id };
      
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      console.error('═══════════════════════════════════════════════════════════');
      console.error('❌ CRITICAL ERROR IN onContactCreated');
      console.error('═══════════════════════════════════════════════════════════');
      console.error('Contact ID:', contactId);
      console.error('Error:', error);
      console.error('Stack:', error.stack);
      console.error(`⏱️  Execution time before failure: ${executionTime}ms`);
      console.error('═══════════════════════════════════════════════════════════');
      
      // Add to dead letter queue for manual review
      await addToDeadLetterQueue(
        'contact_workflow_init',
        { contactId, contact },
        error,
        'onContactCreated'
      );
      
      await recordMetric('function_error', 1, {
        function: 'onContactCreated',
        error: error.message
      });
      
      // Update contact with error status
      try {
        await contactsRef.doc(contactId).update({
          workflowStatus: 'error',
          workflowStatusReason: error.message,
          workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
      } catch (updateError) {
        console.error('Failed to update contact error status:', updateError);
      }
      
      throw error; // Re-throw to trigger Cloud Functions retry
    }
  });

/**
 * Helper function: Check workflow entry conditions
 */
function checkWorkflowEntryConditions(contact, workflow) {
  const reasons = [];
  let eligible = true;
  
  if (!workflow.entryConditions) {
    return { eligible: true, reasons: [] };
  }
  
  // Check email requirement
  if (workflow.entryConditions.requireEmail) {
    if (!contact.emails || !Array.isArray(contact.emails) || contact.emails.length === 0) {
      eligible = false;
      reasons.push('Email address required');
    } else {
      const hasValidEmail = contact.emails.some(e => isValidEmail(e.address));
      if (!hasValidEmail) {
        eligible = false;
        reasons.push('Valid email address required');
      }
    }
  }
  
  // Check phone requirement
  if (workflow.entryConditions.requirePhone) {
    if (!contact.phones || !Array.isArray(contact.phones) || contact.phones.length === 0) {
      eligible = false;
      reasons.push('Phone number required');
    }
  }
  
  // Check contact type
  if (workflow.entryConditions.contactTypes && workflow.entryConditions.contactTypes.length > 0) {
    if (!workflow.entryConditions.contactTypes.includes(contact.contactType)) {
      eligible = false;
      reasons.push(`Contact type must be one of: ${workflow.entryConditions.contactTypes.join(', ')}`);
    }
  }
  
  // Check lead source
  if (workflow.entryConditions.leadSources && workflow.entryConditions.leadSources.length > 0) {
    if (!workflow.entryConditions.leadSources.includes(contact.leadSource)) {
      eligible = false;
      reasons.push(`Lead source must be one of: ${workflow.entryConditions.leadSources.join(', ')}`);
    }
  }
  
  // Check minimum lead score
  if (workflow.entryConditions.minLeadScore) {
    const leadScore = contact.leadScore || 0;
    if (leadScore < workflow.entryConditions.minLeadScore) {
      eligible = false;
      reasons.push(`Lead score must be at least ${workflow.entryConditions.minLeadScore}`);
    }
  }
  
  // Check custom conditions
  if (workflow.entryConditions.customConditions) {
    for (const condition of workflow.entryConditions.customConditions) {
      const field = contact[condition.field];
      
      switch (condition.operator) {
        case 'equals':
          if (field !== condition.value) {
            eligible = false;
            reasons.push(`${condition.field} must equal ${condition.value}`);
          }
          break;
        case 'notEquals':
          if (field === condition.value) {
            eligible = false;
            reasons.push(`${condition.field} must not equal ${condition.value}`);
          }
          break;
        case 'contains':
          if (!field || !field.includes(condition.value)) {
            eligible = false;
            reasons.push(`${condition.field} must contain ${condition.value}`);
          }
          break;
        case 'greaterThan':
          if (!field || field <= condition.value) {
            eligible = false;
            reasons.push(`${condition.field} must be greater than ${condition.value}`);
          }
          break;
        case 'lessThan':
          if (!field || field >= condition.value) {
            eligible = false;
            reasons.push(`${condition.field} must be less than ${condition.value}`);
          }
          break;
      }
    }
  }
  
  return { eligible, reasons };
}

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: processScheduledWorkflows                                   ║
 * ║ TRIGGER: Scheduled (Cron) - Every hour                               ║
 * ║ PURPOSE: Process scheduled workflow stages and send delayed emails   ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.processScheduledWorkflows = functions
  .runWith({
    timeoutSeconds: 540,
    memory: '4GB',
    secrets: ['SENDGRID_API_KEY', 'FROM_EMAIL', 'REPLY_TO_EMAIL']
  })
  .pubsub
  .schedule('every 1 hours')
  .timeZone('America/Los_Angeles')
  .onRun(async (context) => {
    const startTime = Date.now();
    
    console.log('═══════════════════════════════════════════════════════════');
    console.log('⏰ SCHEDULED WORKFLOW PROCESSING STARTED');
    console.log('═══════════════════════════════════════════════════════════');
    console.log('Timestamp:', new Date().toISOString());
    
    try {
      // Check system configuration
      const sysConfig = await getSystemConfig();
      
      if (!sysConfig.enabled || sysConfig.maintenanceMode) {
        console.log('⚠️ Email automation disabled or in maintenance mode');
        return null;
      }
      
      const now = admin.firestore.Timestamp.now();
      
      // Query for scheduled stages that are due
      const dueStagesSnapshot = await scheduledStagesRef
        .where('scheduledFor', '<=', now)
        .where('status', '==', 'pending')
        .orderBy('scheduledFor', 'asc')
        .limit(CONFIG.WORKFLOW.BATCH_SIZE)
        .get();
      
      console.log(`📊 Found ${dueStagesSnapshot.size} scheduled stages to process`);
      
      if (dueStagesSnapshot.empty) {
        console.log('✅ No scheduled stages due for processing');
        await recordMetric('scheduled_processing_run', 1, { stagesProcessed: 0 });
        return null;
      }
      
      const results = {
        total: dueStagesSnapshot.size,
        successful: 0,
        failed: 0,
        skipped: 0,
        errors: []
      };
      
      // Process each scheduled stage
      const processingPromises = dueStagesSnapshot.docs.map(async (doc) => {
        const scheduleId = doc.id;
        const schedule = doc.data();
        
        try {
          console.log(`\n📋 Processing schedule ${scheduleId}:`, {
            contactId: schedule.contactId,
            workflowStateId: schedule.workflowStateId,
            stageIndex: schedule.stageIndex
          });
          
          // Mark as processing
          await doc.ref.update({
            status: 'processing',
            processedAt: admin.firestore.FieldValue.serverTimestamp()
          });
          
          // Check if workflow still exists and is active
          const workflowStateDoc = await workflowStateRef.doc(schedule.workflowStateId).get();
          
          if (!workflowStateDoc.exists) {
            console.log('⚠️ Workflow state not found, skipping');
            await doc.ref.update({ status: 'cancelled', cancelReason: 'workflow_not_found' });
            results.skipped++;
            return;
          }
          
          const workflowState = workflowStateDoc.data();
          
          if (workflowState.status !== 'active') {
            console.log(`⚠️ Workflow status is ${workflowState.status}, skipping`);
            await doc.ref.update({ status: 'cancelled', cancelReason: `workflow_${workflowState.status}` });
            results.skipped++;
            return;
          }
          
          // Process the workflow stage with retry
          const processResult = await retryWithBackoff(
            async () => {
              return await processWorkflowStage(schedule.contactId, schedule.workflowStateId);
            },
            `Scheduled stage for contact ${schedule.contactId}`,
            2 // Fewer retries for scheduled tasks
          );
          
          if (processResult.success) {
            await doc.ref.update({
              status: 'completed',
              completedAt: admin.firestore.FieldValue.serverTimestamp()
            });
            results.successful++;
            console.log('✅ Scheduled stage completed successfully');
          } else {
            await doc.ref.update({
              status: 'failed',
              error: processResult.error.message,
              failedAt: admin.firestore.FieldValue.serverTimestamp()
            });
            results.failed++;
            results.errors.push({
              scheduleId,
              contactId: schedule.contactId,
              error: processResult.error.message
            });
            console.error('❌ Scheduled stage failed:', processResult.error);
            
            // Add to dead letter queue if all retries exhausted
            await addToDeadLetterQueue(
              'scheduled_stage',
              schedule,
              processResult.error,
              'processScheduledWorkflows'
            );
          }
          
        } catch (error) {
          console.error(`❌ Error processing schedule ${scheduleId}:`, error);
          results.failed++;
          results.errors.push({
            scheduleId,
            error: error.message
          });
          
          try {
            await doc.ref.update({
              status: 'failed',
              error: error.message,
              failedAt: admin.firestore.FieldValue.serverTimestamp()
            });
          } catch (updateError) {
            console.error('Failed to update schedule status:', updateError);
          }
        }
      });
      
      // Wait for all processing to complete
      await Promise.all(processingPromises);
      
      // Record metrics
      await recordMetric('scheduled_processing_run', 1, {
        total: results.total,
        successful: results.successful,
        failed: results.failed,
        skipped: results.skipped
      });
      
      // Check if there are more stages to process
      const remainingSnapshot = await scheduledStagesRef
        .where('scheduledFor', '<=', now)
        .where('status', '==', 'pending')
        .limit(1)
        .get();
      
      if (!remainingSnapshot.empty) {
        console.log(`\n⚠️ ${remainingSnapshot.size}+ more stages pending, consider increasing batch size`);
      }
      
      const executionTime = Date.now() - startTime;
      
      console.log('\n═══════════════════════════════════════════════════════════');
      console.log('✅ SCHEDULED WORKFLOW PROCESSING COMPLETE');
      console.log('═══════════════════════════════════════════════════════════');
      console.log('Results:', JSON.stringify(results, null, 2));
      console.log(`⏱️  Total execution time: ${executionTime}ms`);
      console.log('═══════════════════════════════════════════════════════════');
      
      return results;
      
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      console.error('═══════════════════════════════════════════════════════════');
      console.error('❌ CRITICAL ERROR IN processScheduledWorkflows');
      console.error('═══════════════════════════════════════════════════════════');
      console.error('Error:', error);
      console.error('Stack:', error.stack);
      console.error(`⏱️  Execution time before failure: ${executionTime}ms`);
      console.error('═══════════════════════════════════════════════════════════');
      
      await recordMetric('function_error', 1, {
        function: 'processScheduledWorkflows',
        error: error.message
      });
      
      throw error;
    }
  });

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: sendgridWebhook                                             ║
 * ║ TRIGGER: HTTPS - POST /sendgridWebhook                               ║
 * ║ PURPOSE: Receive and process SendGrid email event webhooks           ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.sendgridWebhook = functions
  .runWith({
    timeoutSeconds: 60,
    memory: '1GB'
  })
  .https
  .onRequest(async (req, res) => {
    const startTime = Date.now();
    
    console.log('═══════════════════════════════════════════════════════════');
    console.log('📨 SENDGRID WEBHOOK RECEIVED');
    console.log('═══════════════════════════════════════════════════════════');
    
    try {
      // Verify request method
      if (req.method !== 'POST') {
        console.log('❌ Invalid request method:', req.method);
        return res.status(405).send('Method Not Allowed');
      }
      
      // Check rate limit
      const clientIp = req.ip || req.headers['x-forwarded-for'] || 'unknown';
      const rateLimit = await checkRateLimit('WEBHOOKS_PER_MINUTE', clientIp);
      
      if (!rateLimit.allowed) {
        console.log('⚠️ Rate limit exceeded for webhook:', clientIp);
        await recordMetric('webhook_rate_limited', 1, { ip: clientIp });
        return res.status(429).json({
          error: 'Rate limit exceeded',
          resetAt: new Date(rateLimit.resetAt).toISOString()
        });
      }
      
      // Verify webhook signature (if configured)
      const signature = req.headers['x-twilio-email-event-webhook-signature'];
      const timestamp = req.headers['x-twilio-email-event-webhook-timestamp'];
      
      if (signature && timestamp) {
        const isValid = verifyWebhookSignature(req.rawBody, signature, timestamp);
        
        if (!isValid) {
          console.error('❌ Invalid webhook signature');
          await recordMetric('webhook_signature_invalid', 1);
          return res.status(401).send('Invalid signature');
        }
      }
      
      // Get events from request body
      const events = req.body;
      
      if (!Array.isArray(events)) {
        console.error('❌ Invalid webhook payload (not an array)');
        return res.status(400).send('Invalid payload');
      }
      
      console.log(`📊 Processing ${events.length} webhook events`);
      
      const results = {
        total: events.length,
        processed: 0,
        failed: 0,
        errors: []
      };
      
      // Process each event
      for (const event of events) {
        try {
          await processWebhookEvent(event);
          results.processed++;
        } catch (error) {
          console.error('Error processing webhook event:', error);
          results.failed++;
          results.errors.push({
            event: event.event,
            email: event.email,
            error: error.message
          });
        }
      }
      
      // Record metrics
      await recordMetric('webhook_events_received', events.length);
      await recordMetric('webhook_events_processed', results.processed);
      
      if (results.failed > 0) {
        await recordMetric('webhook_events_failed', results.failed);
      }
      
      const executionTime = Date.now() - startTime;
      
      console.log('═══════════════════════════════════════════════════════════');
      console.log('✅ WEBHOOK PROCESSING COMPLETE');
      console.log('═══════════════════════════════════════════════════════════');
      console.log('Results:', JSON.stringify(results, null, 2));
      console.log(`⏱️  Execution time: ${executionTime}ms`);
      console.log('═══════════════════════════════════════════════════════════');
      
      return res.status(200).json({
        success: true,
        results
      });
      
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      console.error('═══════════════════════════════════════════════════════════');
      console.error('❌ CRITICAL ERROR IN sendgridWebhook');
      console.error('═══════════════════════════════════════════════════════════');
      console.error('Error:', error);
      console.error('Stack:', error.stack);
      console.error(`⏱️  Execution time before failure: ${executionTime}ms`);
      console.error('═══════════════════════════════════════════════════════════');
      
      await recordMetric('function_error', 1, {
        function: 'sendgridWebhook',
        error: error.message
      });
      
      return res.status(500).json({
        error: 'Internal server error',
        message: error.message
      });
    }
  });

/**
 * Helper function: Process individual webhook event
 */
async function processWebhookEvent(event) {
  console.log(`\n📧 Processing event: ${event.event} for ${event.email}`);
  
  // Extract metadata
  const emailAddress = event.email?.toLowerCase();
  const timestamp = event.timestamp ? new Date(event.timestamp * 1000) : new Date();
  const eventType = event.event;
  
  // Find contact by email
  const contactsSnapshot = await contactsRef
    .where('emails', 'array-contains', { address: emailAddress })
    .limit(1)
    .get();
  
  if (contactsSnapshot.empty) {
    console.log('⚠️ No contact found for email:', emailAddress);
    return;
  }
  
  const contactDoc = contactsSnapshot.docs[0];
  const contactId = contactDoc.id;
  
  // Update email log
  const emailLogQuery = await emailLogsRef
    .where('contactId', '==', contactId)
    .where('to', '==', emailAddress)
    .orderBy('sentAt', 'desc')
    .limit(1)
    .get();
  
  if (!emailLogQuery.empty) {
    const emailLogDoc = emailLogQuery.docs[0];
    
    await emailLogDoc.ref.update({
      [`events.${eventType}`]: admin.firestore.FieldValue.arrayUnion({
        timestamp: timestamp.toISOString(),
        reason: event.reason || null,
        url: event.url || null,
        userAgent: event.useragent || null,
        ip: event.ip || null
      }),
      lastEventType: eventType,
      lastEventAt: admin.firestore.FieldValue.serverTimestamp()
    });
  }
  
  // Update contact engagement
  const engagementUpdate = {};
  
  switch (eventType) {
    case 'delivered':
      engagementUpdate.emailDelivered = admin.firestore.FieldValue.increment(1);
      engagementUpdate.lastEmailDeliveredAt = admin.firestore.FieldValue.serverTimestamp();
      break;
    case 'open':
      engagementUpdate.emailOpened = admin.firestore.FieldValue.increment(1);
      engagementUpdate.lastEmailOpenedAt = admin.firestore.FieldValue.serverTimestamp();
      engagementUpdate.engagementScore = admin.firestore.FieldValue.increment(5);
      break;
    case 'click':
      engagementUpdate.emailClicked = admin.firestore.FieldValue.increment(1);
      engagementUpdate.lastEmailClickedAt = admin.firestore.FieldValue.serverTimestamp();
      engagementUpdate.engagementScore = admin.firestore.FieldValue.increment(10);
      break;
    case 'bounce':
      engagementUpdate.emailBounced = admin.firestore.FieldValue.increment(1);
      engagementUpdate.lastEmailBouncedAt = admin.firestore.FieldValue.serverTimestamp();
      engagementUpdate.emailBounceType = event.type || 'unknown';
      break;
    case 'dropped':
      engagementUpdate.emailDropped = admin.firestore.FieldValue.increment(1);
      engagementUpdate.lastEmailDroppedAt = admin.firestore.FieldValue.serverTimestamp();
      engagementUpdate.emailDropReason = event.reason || 'unknown';
      break;
    case 'spamreport':
      engagementUpdate.emailSpamReports = admin.firestore.FieldValue.increment(1);
      engagementUpdate.lastSpamReportAt = admin.firestore.FieldValue.serverTimestamp();
      // Add to unsubscribed list
      await unsubscribedRef.doc(emailAddress).set({
        email: emailAddress,
        reason: 'spam_report',
        timestamp: admin.firestore.FieldValue.serverTimestamp()
      });
      // Pause workflow
      const workflowQuery = await workflowStateRef
        .where('contactId', '==', contactId)
        .where('status', '==', 'active')
        .get();
      for (const doc of workflowQuery.docs) {
        await doc.ref.update({
          status: 'paused',
          pausedAt: admin.firestore.FieldValue.serverTimestamp(),
          pauseReason: 'spam_report'
        });
      }
      break;
    case 'unsubscribe':
      engagementUpdate.unsubscribedAt = admin.firestore.FieldValue.serverTimestamp();
      // Add to unsubscribed list
      await unsubscribedRef.doc(emailAddress).set({
        email: emailAddress,
        reason: 'user_request',
        timestamp: admin.firestore.FieldValue.serverTimestamp()
      });
      // Pause workflow
      const unsubWorkflowQuery = await workflowStateRef
        .where('contactId', '==', contactId)
        .where('status', '==', 'active')
        .get();
      for (const doc of unsubWorkflowQuery.docs) {
        await doc.ref.update({
          status: 'paused',
          pausedAt: admin.firestore.FieldValue.serverTimestamp(),
          pauseReason: 'unsubscribed'
        });
      }
      break;
  }
  
  if (Object.keys(engagementUpdate).length > 0) {
    await contactDoc.ref.update(engagementUpdate);
    console.log('✅ Contact engagement updated');
  }
  
  // Record event metric
  await recordMetric('email_event', 1, {
    eventType,
    contactId
  });
}

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: startWorkflowManual                                         ║
 * ║ TRIGGER: HTTPS Callable - startWorkflowManual({contactId, workflowId})║
 * ║ PURPOSE: Manually start or restart a workflow for a contact          ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.startWorkflowManual = functions
  .runWith({
    timeoutSeconds: 60,
    memory: '1GB',
    secrets: ['SENDGRID_API_KEY', 'FROM_EMAIL', 'REPLY_TO_EMAIL']
  })
  .https
  .onCall(async (data, context) => {
    const startTime = Date.now();
    
    console.log('═══════════════════════════════════════════════════════════');
    console.log('🎯 MANUAL WORKFLOW START REQUEST');
    console.log('═══════════════════════════════════════════════════════════');
    
    try {
      // Verify authentication
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'User must be authenticated to start workflows'
        );
      }
      
      const { contactId, workflowId, force } = data;
      
      if (!contactId || !workflowId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'contactId and workflowId are required'
        );
      }
      
      console.log('Contact ID:', contactId);
      console.log('Workflow ID:', workflowId);
      console.log('Force restart:', force || false);
      console.log('User:', context.auth.uid);
      
      // Get contact
      const contactDoc = await contactsRef.doc(contactId).get();
      
      if (!contactDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'Contact not found'
        );
      }
      
      const contact = { id: contactId, ...contactDoc.data() };
      
      // Validate contact
      const validation = validateContactForEmail(contact);
      if (!validation.isValid) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          `Contact validation failed: ${validation.errors.join(', ')}`
        );
      }
      
      // Check if workflow already exists
      const existingWorkflowQuery = await workflowStateRef
        .where('contactId', '==', contactId)
        .where('status', 'in', ['active', 'paused'])
        .get();
      
      if (!existingWorkflowQuery.empty && !force) {
        throw new functions.https.HttpsError(
          'already-exists',
          'Contact already has an active workflow. Use force=true to restart.'
        );
      }
      
      // Stop existing workflows if force restart
      if (!existingWorkflowQuery.empty && force) {
        console.log('🛑 Stopping existing workflows (force restart)');
        for (const doc of existingWorkflowQuery.docs) {
          await doc.ref.update({
            status: 'stopped',
            stoppedAt: admin.firestore.FieldValue.serverTimestamp(),
            stoppedBy: context.auth.uid,
            stopReason: 'manual_restart'
          });
        }
      }
      
      // Get workflow definition
      const workflow = getWorkflowDefinition(workflowId);
      
      if (!workflow) {
        throw new functions.https.HttpsError(
          'not-found',
          `Workflow definition not found: ${workflowId}`
        );
      }
      
      // Create new workflow state
      const workflowState = {
        contactId,
        workflowId,
        currentStage: 0,
        status: 'active',
        startedAt: admin.firestore.FieldValue.serverTimestamp(),
        startedBy: context.auth.uid,
        lastProcessedAt: null,
        completedAt: null,
        pausedAt: null,
        errorCount: 0,
        stageHistory: [],
        metadata: {
          leadSource: contact.leadSource,
          contactType: contact.contactType,
          initialLeadScore: contact.leadScore || 0,
          workflowVersion: workflow.version || '1.0',
          manualStart: true
        }
      };
      
      const workflowStateDoc = await workflowStateRef.add(workflowState);
      
      console.log('✅ Workflow state created:', workflowStateDoc.id);
      
      // Update contact
      await contactDoc.ref.update({
        workflowId,
        workflowStatus: 'active',
        workflowStateId: workflowStateDoc.id,
        workflowStartedAt: admin.firestore.FieldValue.serverTimestamp(),
        workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // Process first stage
      const processResult = await retryWithBackoff(
        async () => {
          return await processWorkflowStage(contactId, workflowStateDoc.id);
        },
        `Manual workflow start for contact ${contactId}`
      );
      
      if (!processResult.success) {
        throw new functions.https.HttpsError(
          'internal',
          `Failed to process first stage: ${processResult.error.message}`
        );
      }
      
      // Log audit
      await logAudit('workflow_started_manual', context.auth.uid, {
        contactId,
        workflowId,
        workflowStateId: workflowStateDoc.id,
        force
      });
      
      await recordMetric('workflow_started_manual', 1, { workflowId });
      
      const executionTime = Date.now() - startTime;
      
      console.log('═══════════════════════════════════════════════════════════');
      console.log('✅ MANUAL WORKFLOW START COMPLETE');
      console.log(`⏱️  Execution time: ${executionTime}ms`);
      console.log('═══════════════════════════════════════════════════════════');
      
      return {
        success: true,
        workflowStateId: workflowStateDoc.id,
        message: 'Workflow started successfully'
      };
      
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      console.error('═══════════════════════════════════════════════════════════');
      console.error('❌ ERROR IN startWorkflowManual');
      console.error('═══════════════════════════════════════════════════════════');
      console.error('Error:', error);
      console.error(`⏱️  Execution time before failure: ${executionTime}ms`);
      console.error('═══════════════════════════════════════════════════════════');
      
      await recordMetric('function_error', 1, {
        function: 'startWorkflowManual',
        error: error.message
      });
      
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }
      
      throw new functions.https.HttpsError(
        'internal',
        error.message
      );
    }
  });

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: pauseWorkflow                                               ║
 * ║ TRIGGER: HTTPS Callable - pauseWorkflow({workflowStateId, reason})   ║
 * ║ PURPOSE: Pause an active workflow                                     ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.pauseWorkflow = functions
  .runWith({
    timeoutSeconds: 30,
    memory: '512MB'
  })
  .https
  .onCall(async (data, context) => {
    console.log('═══════════════════════════════════════════════════════════');
    console.log('⏸️  PAUSE WORKFLOW REQUEST');
    console.log('═══════════════════════════════════════════════════════════');
    
    try {
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'User must be authenticated'
        );
      }
      
      const { workflowStateId, reason } = data;
      
      if (!workflowStateId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'workflowStateId is required'
        );
      }
      
      const workflowDoc = await workflowStateRef.doc(workflowStateId).get();
      
      if (!workflowDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'Workflow not found'
        );
      }
      
      const workflow = workflowDoc.data();
      
      if (workflow.status !== 'active') {
        throw new functions.https.HttpsError(
          'failed-precondition',
          `Cannot pause workflow with status: ${workflow.status}`
        );
      }
      
      await workflowDoc.ref.update({
        status: 'paused',
        pausedAt: admin.firestore.FieldValue.serverTimestamp(),
        pausedBy: context.auth.uid,
        pauseReason: reason || 'manual_pause'
      });
      
      // Update contact
      await contactsRef.doc(workflow.contactId).update({
        workflowStatus: 'paused',
        workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // Log audit
      await logAudit('workflow_paused', context.auth.uid, {
        workflowStateId,
        contactId: workflow.contactId,
        reason
      });
      
      await recordMetric('workflow_paused', 1);
      
      console.log('✅ Workflow paused successfully');
      
      return {
        success: true,
        message: 'Workflow paused successfully'
      };
      
    } catch (error) {
      console.error('❌ Error pausing workflow:', error);
      
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }
      
      throw new functions.https.HttpsError('internal', error.message);
    }
  });

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: resumeWorkflow                                              ║
 * ║ TRIGGER: HTTPS Callable - resumeWorkflow({workflowStateId})          ║
 * ║ PURPOSE: Resume a paused workflow                                     ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.resumeWorkflow = functions
  .runWith({
    timeoutSeconds: 60,
    memory: '1GB',
    secrets: ['SENDGRID_API_KEY', 'FROM_EMAIL', 'REPLY_TO_EMAIL']
  })
  .https
  .onCall(async (data, context) => {
    console.log('═══════════════════════════════════════════════════════════');
    console.log('▶️  RESUME WORKFLOW REQUEST');
    console.log('═══════════════════════════════════════════════════════════');
    
    try {
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'User must be authenticated'
        );
      }
      
      const { workflowStateId } = data;
      
      if (!workflowStateId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'workflowStateId is required'
        );
      }
      
      const workflowDoc = await workflowStateRef.doc(workflowStateId).get();
      
      if (!workflowDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'Workflow not found'
        );
      }
      
      const workflow = workflowDoc.data();
      
      if (workflow.status !== 'paused') {
        throw new functions.https.HttpsError(
          'failed-precondition',
          `Cannot resume workflow with status: ${workflow.status}`
        );
      }
      
      await workflowDoc.ref.update({
        status: 'active',
        resumedAt: admin.firestore.FieldValue.serverTimestamp(),
        resumedBy: context.auth.uid,
        pausedAt: null,
        pauseReason: null
      });
      
      // Update contact
      await contactsRef.doc(workflow.contactId).update({
        workflowStatus: 'active',
        workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // Process next stage immediately
      const processResult = await retryWithBackoff(
        async () => {
          return await processWorkflowStage(workflow.contactId, workflowStateId);
        },
        `Resume workflow for contact ${workflow.contactId}`
      );
      
      if (!processResult.success) {
        console.warn('⚠️ Failed to process stage after resume:', processResult.error);
      }
      
      // Log audit
      await logAudit('workflow_resumed', context.auth.uid, {
        workflowStateId,
        contactId: workflow.contactId
      });
      
      await recordMetric('workflow_resumed', 1);
      
      console.log('✅ Workflow resumed successfully');
      
      return {
        success: true,
        message: 'Workflow resumed successfully'
      };
      
    } catch (error) {
      console.error('❌ Error resuming workflow:', error);
      
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }
      
      throw new functions.https.HttpsError('internal', error.message);
    }
  });

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: stopWorkflow                                                ║
 * ║ TRIGGER: HTTPS Callable - stopWorkflow({workflowStateId, reason})    ║
 * ║ PURPOSE: Permanently stop a workflow                                  ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.stopWorkflow = functions
  .runWith({
    timeoutSeconds: 30,
    memory: '512MB'
  })
  .https
  .onCall(async (data, context) => {
    console.log('═══════════════════════════════════════════════════════════');
    console.log('🛑 STOP WORKFLOW REQUEST');
    console.log('═══════════════════════════════════════════════════════════');
    
    try {
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'User must be authenticated'
        );
      }
      
      const { workflowStateId, reason } = data;
      
      if (!workflowStateId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'workflowStateId is required'
        );
      }
      
      const workflowDoc = await workflowStateRef.doc(workflowStateId).get();
      
      if (!workflowDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'Workflow not found'
        );
      }
      
      const workflow = workflowDoc.data();
      
      if (workflow.status === 'completed' || workflow.status === 'stopped') {
        throw new functions.https.HttpsError(
          'failed-precondition',
          `Workflow already ${workflow.status}`
        );
      }
      
      await workflowDoc.ref.update({
        status: 'stopped',
        stoppedAt: admin.firestore.FieldValue.serverTimestamp(),
        stoppedBy: context.auth.uid,
        stopReason: reason || 'manual_stop'
      });
      
      // Update contact
      await contactsRef.doc(workflow.contactId).update({
        workflowStatus: 'stopped',
        workflowStatusUpdatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // Cancel any scheduled stages
      const scheduledQuery = await scheduledStagesRef
        .where('workflowStateId', '==', workflowStateId)
        .where('status', '==', 'pending')
        .get();
      
      for (const doc of scheduledQuery.docs) {
        await doc.ref.update({
          status: 'cancelled',
          cancelReason: 'workflow_stopped',
          cancelledAt: admin.firestore.FieldValue.serverTimestamp()
        });
      }
      
      // Log audit
      await logAudit('workflow_stopped', context.auth.uid, {
        workflowStateId,
        contactId: workflow.contactId,
        reason
      });
      
      await recordMetric('workflow_stopped', 1);
      
      console.log('✅ Workflow stopped successfully');
      
      return {
        success: true,
        message: 'Workflow stopped successfully'
      };
      
    } catch (error) {
      console.error('❌ Error stopping workflow:', error);
      
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }
      
      throw new functions.https.HttpsError('internal', error.message);
    }
  });

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: getWorkflowStatus                                           ║
 * ║ TRIGGER: HTTPS Callable - getWorkflowStatus({contactId})             ║
 * ║ PURPOSE: Get detailed workflow status for a contact                   ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.getWorkflowStatus = functions
  .runWith({
    timeoutSeconds: 30,
    memory: '512MB'
  })
  .https
  .onCall(async (data, context) => {
    try {
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'User must be authenticated'
        );
      }
      
      const { contactId } = data;
      
      if (!contactId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'contactId is required'
        );
      }
      
      // Get contact
      const contactDoc = await contactsRef.doc(contactId).get();
      
      if (!contactDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'Contact not found'
        );
      }
      
      const contact = contactDoc.data();
      
      // Get active workflow states
      const workflowQuery = await workflowStateRef
        .where('contactId', '==', contactId)
        .orderBy('startedAt', 'desc')
        .get();
      
      const workflows = workflowQuery.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        startedAt: doc.data().startedAt?.toDate().toISOString(),
        lastProcessedAt: doc.data().lastProcessedAt?.toDate().toISOString(),
        completedAt: doc.data().completedAt?.toDate().toISOString(),
        pausedAt: doc.data().pausedAt?.toDate().toISOString()
      }));
      
      // Get email logs
      const emailLogsQuery = await emailLogsRef
        .where('contactId', '==', contactId)
        .orderBy('sentAt', 'desc')
        .limit(10)
        .get();
      
      const emails = emailLogsQuery.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        sentAt: doc.data().sentAt?.toDate().toISOString()
      }));
      
      // Get scheduled stages
      const scheduledQuery = await scheduledStagesRef
        .where('contactId', '==', contactId)
        .where('status', '==', 'pending')
        .orderBy('scheduledFor', 'asc')
        .get();
      
      const scheduled = scheduledQuery.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        scheduledFor: doc.data().scheduledFor?.toDate().toISOString()
      }));
      
      return {
        success: true,
        contact: {
          id: contactId,
          workflowStatus: contact.workflowStatus,
          workflowId: contact.workflowId
        },
        workflows,
        emails,
        scheduled
      };
      
    } catch (error) {
      console.error('Error getting workflow status:', error);
      
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }
      
      throw new functions.https.HttpsError('internal', error.message);
    }
  });

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: healthCheck                                                 ║
 * ║ TRIGGER: HTTPS - GET /healthCheck                                    ║
 * ║ PURPOSE: System health monitoring and diagnostics                    ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.healthCheck = functions
  .runWith({
    timeoutSeconds: 30,
    memory: '512MB'
  })
  .https
  .onRequest(async (req, res) => {
    const startTime = Date.now();
    
    try {
      const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        version: '2.0.0',
        checks: {}
      };
      
      // Check Firestore connectivity
      try {
        await db.collection('systemConfig').doc('health').get();
        health.checks.firestore = 'healthy';
      } catch (error) {
        health.checks.firestore = 'unhealthy';
        health.status = 'degraded';
      }
      
      // Check SendGrid configuration
      health.checks.sendgrid = {
        configured: !!SENDGRID_API_KEY && !!FROM_EMAIL,
        status: (!!SENDGRID_API_KEY && !!FROM_EMAIL) ? 'healthy' : 'unhealthy'
      };
      
      // Get active workflows count
      try {
        const activeWorkflows = await workflowStateRef
          .where('status', '==', 'active')
          .count()
          .get();
        health.checks.activeWorkflows = activeWorkflows.data().count;
      } catch (error) {
        health.checks.activeWorkflows = 'error';
      }
      
      // Get pending scheduled stages
      try {
        const now = admin.firestore.Timestamp.now();
        const pendingStages = await scheduledStagesRef
          .where('scheduledFor', '<=', now)
          .where('status', '==', 'pending')
          .count()
          .get();
        health.checks.pendingStages = pendingStages.data().count;
      } catch (error) {
        health.checks.pendingStages = 'error';
      }
      
      // Get recent errors
      try {
        const recentErrors = await deadLetterQueueRef
          .where('timestamp', '>', admin.firestore.Timestamp.fromDate(new Date(Date.now() - 3600000)))
          .count()
          .get();
        health.checks.recentErrors = recentErrors.data().count;
        
        if (recentErrors.data().count > 10) {
          health.status = 'degraded';
        }
      } catch (error) {
        health.checks.recentErrors = 'error';
      }
      
      // Response time
      health.responseTime = Date.now() - startTime;
      
      const statusCode = health.status === 'healthy' ? 200 : 503;
      
      return res.status(statusCode).json(health);
      
    } catch (error) {
      console.error('Health check error:', error);
      
      return res.status(503).json({
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        error: error.message
      });
    }
  });

/**
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║ FUNCTION: cleanupOldLogs                                              ║
 * ║ TRIGGER: Scheduled (Cron) - Daily at 2 AM                            ║
 * ║ PURPOSE: Delete old logs and metrics to manage storage               ║
 * ╚═══════════════════════════════════════════════════════════════════════╝
 */
exports.cleanupOldLogs = functions
  .runWith({
    timeoutSeconds: 540,
    memory: '2GB'
  })
  .pubsub
  .schedule('0 2 * * *')
  .timeZone('America/Los_Angeles')
  .onRun(async (context) => {
    console.log('═══════════════════════════════════════════════════════════');
    console.log('🧹 CLEANUP OLD LOGS STARTED');
    console.log('═══════════════════════════════════════════════════════════');
    
    try {
      const results = {
        emailLogs: 0,
        systemMetrics: 0,
        auditLogs: 0,
        scheduledStages: 0,
        deadLetterQueue: 0
      };
      
      // Delete old email logs
      const emailLogsCutoff = new Date();
      emailLogsCutoff.setDate(emailLogsCutoff.getDate() - CONFIG.MONITORING.LOG_RETENTION_DAYS);
      
      const oldEmailLogs = await emailLogsRef
        .where('sentAt', '<', admin.firestore.Timestamp.fromDate(emailLogsCutoff))
        .limit(500)
        .get();
      
      for (const doc of oldEmailLogs.docs) {
        await doc.ref.delete();
        results.emailLogs++;
      }
      
      // Delete old metrics
      const metricsCutoff = new Date();
      metricsCutoff.setDate(metricsCutoff.getDate() - CONFIG.MONITORING.METRICS_RETENTION_DAYS);
      
      const oldMetrics = await systemMetricsRef
        .where('timestamp', '<', admin.firestore.Timestamp.fromDate(metricsCutoff))
        .limit(1000)
        .get();
      
      for (const doc of oldMetrics.docs) {
        await doc.ref.delete();
        results.systemMetrics++;
      }
      
      // Delete old audit logs
      const oldAuditLogs = await auditLogsRef
        .where('timestamp', '<', admin.firestore.Timestamp.fromDate(emailLogsCutoff))
        .limit(500)
        .get();
      
      for (const doc of oldAuditLogs.docs) {
        await doc.ref.delete();
        results.auditLogs++;
      }
      
      // Delete completed scheduled stages older than 7 days
      const scheduledCutoff = new Date();
      scheduledCutoff.setDate(scheduledCutoff.getDate() - 7);
      
      const oldScheduled = await scheduledStagesRef
        .where('status', 'in', ['completed', 'cancelled'])
        .where('completedAt', '<', admin.firestore.Timestamp.fromDate(scheduledCutoff))
        .limit(500)
        .get();
      
      for (const doc of oldScheduled.docs) {
        await doc.ref.delete();
        results.scheduledStages++;
      }
      
      // Archive old dead letter queue items (don't delete)
      const dlqCutoff = new Date();
      dlqCutoff.setDate(dlqCutoff.getDate() - 30);
      
      const oldDLQ = await deadLetterQueueRef
        .where('timestamp', '<', admin.firestore.Timestamp.fromDate(dlqCutoff))
        .limit(100)
        .get();
      
      for (const doc of oldDLQ.docs) {
        await doc.ref.update({
          archived: true,
          archivedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        results.deadLetterQueue++;
      }
      
      console.log('═══════════════════════════════════════════════════════════');
      console.log('✅ CLEANUP COMPLETE');
      console.log('═══════════════════════════════════════════════════════════');
      console.log('Results:', JSON.stringify(results, null, 2));
      console.log('═══════════════════════════════════════════════════════════');
      
      return results;
      
    } catch (error) {
      console.error('❌ Cleanup error:', error);
      throw error;
    }
  });

/**
 * ═══════════════════════════════════════════════════════════════════════════
 * ADMIN FUNCTIONS - Emergency Controls
 * ═══════════════════════════════════════════════════════════════════════════
 */

/**
 * Enable/disable email automation system
 */
exports.setSystemEnabled = functions
  .https
  .onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }
    
    // TODO: Add admin role check
    
    const { enabled } = data;
    
    await configRef.doc('email_automation').set({
      enabled,
      lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
      updatedBy: context.auth.uid
    }, { merge: true });
    
    // Clear config cache
    configCache = null;
    
    await logAudit('system_enabled_changed', context.auth.uid, { enabled });
    
    return { success: true, enabled };
  });

/**
 * Emergency stop all workflows
 */
exports.emergencyStopAll = functions
  .runWith({
    timeoutSeconds: 540,
    memory: '2GB'
  })
  .https
  .onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }
    
    // TODO: Add admin role check
    
    console.log('🚨 EMERGENCY STOP ALL WORKFLOWS');
    
    const { reason } = data;
    
    // Pause all active workflows
    const activeWorkflows = await workflowStateRef
      .where('status', '==', 'active')
      .get();
    
    let count = 0;
    
    for (const doc of activeWorkflows.docs) {
      await doc.ref.update({
        status: 'paused',
        pausedAt: admin.firestore.FieldValue.serverTimestamp(),
        pausedBy: context.auth.uid,
        pauseReason: `emergency_stop: ${reason || 'no reason provided'}`
      });
      count++;
    }
    
    // Set maintenance mode
    await configRef.doc('email_automation').set({
      maintenanceMode: true,
      lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
      updatedBy: context.auth.uid
    }, { merge: true });
    
    configCache = null;
    
    await logAudit('emergency_stop_all', context.auth.uid, { count, reason });
    
    console.log(`✅ Paused ${count} workflows`);
    
    return { success: true, workflowsPaused: count };
  });

/**
 * ═══════════════════════════════════════════════════════════════════════════
 * END OF EMAILFUNCTIONS.JS - MEGA ENTERPRISE EDITION
 * ═══════════════════════════════════════════════════════════════════════════
 */